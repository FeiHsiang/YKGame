<!doctype html>
<html >
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>射擊小遊戲</title>
	<style>

		html, body {
			overflow: hidden;
			background: #fff;
			color: #000;
			font-family: sans-serif;
			text-align: center;
			width:100vw;
			height:100vh;
			margin: 0;
		}

		#aDiv{
			/* margin: 20px 10px; */
			/* width:800px; */
			/* height:600px; */
			position: relative;
			width:100vw;
			height:100vh;
		}

		#blocker {
			display: none;
			position: absolute;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0,0,0,0.8);
			z-index: 1;
			pointer-events: none;
		}


		#blockerTitle{
			font-size: 24pt;
			text-align: center;
			margin-top:5%;
			margin-bottom: 10px;
		}

		#blockerInfo{
			font-size: 16pt;
			text-align: center;
			color:#00c99c;
			margin-top:20%;
			margin-bottom: 10px;
		}

		#blockState{
			font-size: 16pt;
			text-align: center;
			color: white;
			margin-top:20%;
			margin-bottom: 10px;
		}

		.modal {
			display: none; /* Hidden by default */
			position: fixed; /* Stay in place */
			z-index: 1; /* Sit on top */
			left: 0;
			top: 0;
			/* https://stackoverflow.com/questions/10075524/sizing-div-based-on-window-width/35237091#35237091 */
			width: 100vw; /* Full width */
			height: 100vh; /* Full height */
			background-color: rgba( 74 , 77 , 84 , 0.85 ); /* Black w/ opacity */
		}

		/* Modal Content/Box */
		.modal-content {
			position: relative;
			background-color: #202125;
			margin: auto;
			top: 5%;
			border-radius: 16px;
			width: 85vw;
			height: 75vh;
			overflow: auto;
		}

		.modal-content > div {
			position: relative;
			margin-left: 2%;
			margin-right: 2%;
			width: 90%;
			color:white;
			text-align: left;
			font-size: 20pt;
		}


		.centerText {
			margin: 0;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			white-space:nowrap;
		}
		
		/* 結算畫面  ----------------------- start ---------------------------  */


		#blocker_score {
			display: none;
			position: absolute;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.7);
			z-index: 1;
		}

		#previousCoins{
			margin-top: 40px;
		}

		#getCoins{
			margin-top: 20px;
		}

		#currentCoins{
			margin-top: 20px;
		}

		#score_info{
			right:-40%;
			width:50%;
			height:auto;
			font-size:18px; 
			color:#00c99c;
			border: 2px solid white;
			padding:10px;
		}

		#leaderBn , #leaveConfirm {
			position:absolute;
			bottom: 15px;
			left:3px;
			width:40%;
			height:20%;
			max-height: 50px;
			border-radius: 20px;
			background-color: rgba(80, 160, 150, 1.0);
			cursor: pointer;
		}

		#couponPage, #leaveCancel{
			position:absolute;
			bottom: 15px;
			right:3px;
			width:40%;
			height:20%;
			max-height: 50px;
			border-radius: 20px;
			background-color: rgba(80, 110, 150, 1.0);
			cursor: pointer;
		}

		/* 結算畫面  ----------------------- end ---------------------------  */

		/* 排行榜    ----------------------- start --------------------------- */

		#leadBnTitle{
			position: relative;
			margin-top: 15px;
			margin-bottom: 30px;
			min-height: 30px;
			text-align: center;
		}

		#leadBnImg{
			position: absolute;
			width:60px;
			height:60px;
			left:5px ;
		}

		#leadBnInfo{
			position: relative;
			font-size: 30px;
			color: #afb4f9;
			left: 32px ;
			top:15px;
		}

		#leaderTable{
			margin: auto;
			width:90%;
			color:white;
			font-size:14pt;
			overflow-wrap:anywhere;
		}

		#closeLeadBnModal{
			color: rgba(20,20,20,1.0);
			background-color: rgba(200,200,200,1.0);
			position: absolute;
			bottom: 10px;
			width: 40%;
			height:30px;
			left:30%;
			font-size: 18px;
			cursor: pointer;
		}

		/* 排行榜    ----------------------- end --------------------------- */

		/* 離開警告  ----------------------- start --------------------------- */

		#warningInfo{
			text-align: center;
			top: 40%;
		}
		
		#leaveButton{
			position: absolute;
			z-index: 2;
			font-size: 15pt;
			color:rgba(0,0,0,0.9);
			background-color:rgba(220,220,220,1.0);
			padding: 5px;
			cursor:pointer;
		}

		/* 離開警告  ----------------------- end --------------------------- */


		#scoreNow{
			position: absolute;
			z-index: 2;
			left :5%;
			bottom: 2%;		
			font-size: 18pt;
			font-family: Arial;
			color:white;
			background-color: rgba(0,0,0,0.9);
		}

		#countdown{
			position: absolute;
			z-index: 2;
			right :5%;
			bottom: 2%;		
			font-size: 18pt;
			font-family: Arial;
			color:white;
			background-color: rgba(0,0,0,0.9);
		}

		.a-dialog-allow-button {
		  background-color: red;
		}

		@media screen and (min-width: 300px) and (max-width: 700px) {
			#aDiv{
				/* margin: 20px 10px; */
				/* width:400px; */
				/* height:300px; */
				position: relative;
				width:100vw;
				height:100vh;
			}
		}


		/* 載入頁面 -------------------------- start  -------------------------- */

		#loadPage{
			display: block;
			position: absolute;
			top:0px;
			width:100vw;
			height:100vh;
			background-color: rgba(128,128,128,0.5);
			z-index: 1;
			text-align: center;
			font-size: 32pt;
			line-height: 80vh;
		}

		#loadObject{
			position: absolute;
			top:10%;
			left:40%;
			font-size: 20pt;
		}

		.lds-ellipsis {
			display: inline-block;
			position: relative;
			width: 80px;
			height: 50px;
		}
		.lds-ellipsis div {
			position: absolute;
			top: 33px;
			width: 13px;
			height: 13px;
			border-radius: 50%;
			background: #000000;
			animation-timing-function: cubic-bezier(0, 1, 1, 0);
		}
		.lds-ellipsis div:nth-child(1) {
			left: 8px;
			animation: lds-ellipsis1 0.6s infinite;
		}
		.lds-ellipsis div:nth-child(2) {
			left: 8px;
			animation: lds-ellipsis2 0.6s infinite;
		}
		.lds-ellipsis div:nth-child(3) {
			left: 32px;
			animation: lds-ellipsis2 0.6s infinite;
		}
		.lds-ellipsis div:nth-child(4) {
			left: 56px;
			animation: lds-ellipsis3 0.6s infinite;
		}
		@keyframes lds-ellipsis1 {
			0% {
				transform: scale(0);
			}
			100% {
				transform: scale(1);
			}
		}
		@keyframes lds-ellipsis3 {
			0% {
				transform: scale(1);
			}
			100% {
				transform: scale(0);
			}
		}
		@keyframes lds-ellipsis2 {
			0% {
				transform: translate(0, 0);
			}
			100% {
				transform: translate(24px, 0);
			}
		}

		/* 載入頁面 -------------------------- end  -------------------------- */


	</style>


</head>
<body>

	<script src = "/scripts/main.js"></script>
	
	<div id = "loadPage">
		Loading 

		<div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>

		<div id = "loadObject"> 載入物件 </div>
	</div>

	<div id = "leaveButton" >
		回遊戲首頁
	</div>

	<div id="blocker">
		<div class="modal-content">
			<div id = "blockerTitle">
				射擊小遊戲
			</div>
			<div id = "blockerInfo"> 
				滑鼠/手指點擊螢幕來射箭<br/>
				手機上請轉動裝置來瞄準<br>
				在15秒鐘內擊中禮物氣球<br/>
			</div>
			<div id = "blockState">
				載入中...
			</div>
		</div>
	</div>

	<div id="blocker_score" class="modal">
		<div class="modal-content">
			<div id = "previousCoins">原有代幣：</div>
			<div id = "getCoins">新增代幣：</div>
			<hr>
			<div id = "currentCoins">結算代幣：</div>
			<div id = "score_info"> </div>
			<div id = "leaderBn"> <div class="centerText">排行榜</div></div>
			<div id = "couponPage" > <div class="centerText">去兌換</div></div>
		</div>
	</div>

	<div id="leadBnModal" class="modal">
        <div class="modal-content">
			<div id="leadBnTitle">
				<img id="leadBnImg" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/images/coin.png">
				<span id="leadBnInfo">永康幣排行榜</span>
			</div>
			<table id = "leaderTable" ></table>

			<div id="closeLeadBnModal" >
				<p  class = "centerText" >關閉</p> 
			</div>
		  
        </div>
	</div>
	
	<div id="leaveWarning" class="modal">
		<div class="modal-content">
			
			<div id = "warningInfo"> 確認回到遊戲首頁嘛？ </div>


			<div id = "leaveConfirm"> <div class="centerText">確認</div></div>
			<div id = "leaveCancel" > <div class="centerText">取消</div></div>

		</div>
	</div>

	<div id = "scoreNow">
		分數：0
	</div>

	<div id = "countdown">
		時間： 15
	</div>

	<script src="js/vconsole.min.js"></script>
	<script>
		if ( window.navigator.userAgent.toLowerCase().indexOf("mobile") >= 0 && window.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 ){
			var vConsole = new VConsole();
			console.log("The system is mobile: ", window.navigator.userAgent.toLowerCase() );
		}else{
			console.log("The system is PC: ", window.navigator.userAgent.toLowerCase() );
		}


		document.getElementById("leaveButton").addEventListener('click', function(){
			if (blocker_score.style.display == "block"){
				location.replace("/games");
			}else{
				leaveWarning.style.display = "block";
				leaveConfirm.onclick = function(){
					location.replace("/games");
				}
				leaveCancel.onclick = function(){
					leaveWarning.style.display = "none";
				}
			}
		});

		// blocker.style.display = "none";
	</script>

	<script src="js/aframe-v1.0.4.js"></script>
	<script src="js/aframe-extras.js"></script>

	<script src="js/aframe-physics-system.js"></script>


	<div id = "aDiv"  >
		<a-scene id = "aScene" embedded="" vr-mode-ui="enabled: false" 
		device-orientation-permission-ui="enabled: true"  shadow="type: pcfsoft"
		physics="debug: false; friction: 50.0 ; restitution: 0.2; gravity: -4.0; maxInterval: 0.0333;" >
			<a-assets id = "aAssets" timeout = "20000">

				<a-asset-item id="_arrow" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/ARGame/games/model/Arrow.glb"></a-asset-item>
				<a-asset-item id="_bow" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/ARGame/games/model/BowAnimation2.glb"></a-asset-item>
				<a-asset-item id="b1" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/ARGame/games/model/balloon01.glb"></a-asset-item>
				<a-asset-item id="b2" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/ARGame/games/model/balloon02.glb"></a-asset-item>
				<a-asset-item id="b3" src="https://yongkangfile.s3-ap-northeast-1.amazonaws.com/ARGame/games/model/balloon03.glb"></a-asset-item>

			</a-assets>

			<a-entity id="rig" position="0 1.6 0" rotation="0 0 0">
				<a-entity id="aCamera" camera  look-controls="touchEnabled:false" wasd-controls>
					<a-entity id = "pivotGun" position="0 -0.6 -1.2" rotation="90 0 0" >
						<a-entity id = "bow" visible = "true" position="0.0 0.05 .0" rotation="-90 0 0" scale=" 0.2 0.2 0.2 " gltf-model="#_bow" ></a-entity>
						<a-entity id = "arrow" visible = "false" position="0 0.13 0" rotation="180 0 0" scale=" 0.6 0.2 0.6 " gltf-model="#_arrow" ></a-entity>
					</a-entity>
				</a-entity>
			</a-entity>

			<!-- <a-box id = "ground2" width="8" height="0.1" depth="20" position="0 -5 0" visible="true" shadow="receive: true"></a-box> -->
			<a-plane id = "ground" material="side:double;" position="0 4 -4" rotation="-90 0 0" width="180" height="200" color="#7BC8A4" opacity="1.0" shadow="receive: true" visible="false"></a-plane>


			
			<!-- <a-sky id = "aSky" color="#ECECEC"></a-sky> -->

			<a-entity light="type: ambient; color: #fff; intensity: 1.0" ></a-entity>
			<a-entity light="type: directional; color: #fff; intensity: 0.5;
								   castShadow: false; 
								   shadowCameraVisible: false;
								   shadowBias:-0.0005; 
								   shadowCameraTop:10; shadowCameraBottom:-10; 
								   shadowCameraRight:10; shadowCameraLeft:-10; 
								   shadowMapHeight:3072; shadowMapWidth:3072; 
								   shadowCameraFar: 500; shadowCameraNear: 0.5;" 
			          position="0 0 1" ></a-entity>
			<!-- <a-entity camera="active: true" look-controls wasd-controls position="0 1.6 0"></a-entity> -->
		</a-scene>

	</div>	

	<script>

		//// 處理載入畫面，呈現當時載入狀況
		let assetList = [];
		document.getElementById("aAssets").addEventListener("progress", function(ret){
			if (ret.detail.loadedBytes == ret.detail.totalBytes ){
				console.log(" _aAssets: progress: ret=" , ret.target.id  );
				loadObject.innerHTML = ret.target.id;
				assetList.push(ret.target.id);
			}
			if (assetList.length == document.getElementById("aAssets").children.length ){
				console.log(" _aAssets: progress: load done ? ");
				loadObject.innerHTML = "物件載入完成";
			}
		});

		document.getElementById("aScene").addEventListener("loaded", function(){
			console.log(" _aScene: loaded " );
			loadObject.innerHTML = "場景載入完成";
		});
		
		document.getElementById("aScene").addEventListener("renderstart", function(){
			console.log(" _aScene: renderstart " );
			loadObject.innerHTML = "場景繪製";
			// loadPage.style.display = "none";
		});

		//// 弓的動畫
		bow.setAttribute("animation-mixer" , "clip: Take 001");
		bow.addEventListener('model-loaded', function(evt){

			tick_getMixer();
			function tick_getMixer(){
				if (bow.components["animation-mixer"].mixer){
					console.log(" got mixer: " , bow.components["animation-mixer"].mixer );
					bow.components["animation-mixer"].mixer._actions[0].timeScale = 1.5;
				}else{
					console.log(" get mixer tick ");
					setTimeout(tick_getMixer);
				}
			}

			console.log(" model-loaded: " , evt.detail.model.animations  );
			let animationSlices = [];
			animationSlices.push({ 
				changed:false, 
				loop:false, 
				reset:false, 
				stopHead: true,
				count: 0, 
				idle:"mifly168", 
				uid:"mifly168" 
			});
			animationSlices.push({
				animationName: evt.detail.model.animations[0].name,
				name: evt.detail.model.animations[0].name,
				endTime: evt.detail.model.animations[0].duration ,
				startTime: 0,
				uid:"mifly168"
			});

			evt.detail.model.animationSlices = animationSlices;
		
		});

		//// 設定場景功能，分為 
		//// 1. 按住滑鼠/觸控 來拖拉物件，不可拖拉出特定圓圈範圍。
		//// 2. 放開滑鼠/觸控 來拋射物件，依照移動參數來設定拋射參數。
		//// 3. 設定拋射物件的後續狀況。
		////

		let aScene = document.getElementById("aScene");
		let aRig =  document.getElementById("rig"); //// 原始位置為 (0, 1.6, 0)
		let pivotGun = document.getElementById("pivotGun");
		
		//// 假如在電腦上，取消 look-control 功能，假如在手機上，隱藏槍
		aCamera.addEventListener('loaded', function(evt) { 
			if (window.navigator.userAgent.toLowerCase().indexOf("mobile") < 0){
				console.log(" PC, remove look wasd control ");
				aCamera.removeAttribute("look-controls");
				aCamera.removeAttribute("wasd-controls");
			}else{
				// pivotGun.setAttribute("visible", "false");
			}
		});
		

		let mouse = new THREE.Vector2();
		let mouseEnd = new THREE.Vector2();
		
		aScene.canvas.style.cursor = "crosshair";

		aScene.canvas.addEventListener("mousemove", vrSceneTouchMove, false);
		aScene.canvas.addEventListener("touchmove", vrSceneTouchMove, false);

		aScene.canvas.addEventListener("mouseup", vrSceneTouchEnd, false);
		aScene.canvas.addEventListener("touchend", vrSceneTouchEnd, false);

		function vrSceneTouchMove(event){
			event.preventDefault();

			let rect = aScene.renderer.domElement.getBoundingClientRect();
			switch ( event.type ) {
				case "mousemove": ////// 20190709 Fei: add this event type for PC mouse
					mouse.x = ( (event.clientX - rect.left) / aScene.renderer.domElement.clientWidth ) * 2 - 1;
					mouse.y = - ( (event.clientY - rect.top) / aScene.renderer.domElement.clientHeight ) * 2 + 1;
					
					break;
				case "touchmove": ////// 20190709 Fei: add this event type for cellphone
					mouse.x = ( (event.changedTouches[0].clientX - rect.left) / aScene.renderer.domElement.clientWidth ) * 2 - 1;
					mouse.y = - ( (event.changedTouches[0].clientY - rect.top) / aScene.renderer.domElement.clientHeight ) * 2 + 1;

					break;

				default:
					console.log(" startEvent: event.type=", event.type, " not mousemove/touchmove, return ");
					return ;

			}

			if (aScene.camera){
					//// 電腦端，需要用滑鼠控制槍管， x[70, 150], y[-90, 90];
				if (window.navigator.userAgent.toLowerCase().indexOf("mobile") < 0){
					pivotGun.object3D.rotation.x = (70 + 40*(1+mouse.y) )/180*Math.PI;
					pivotGun.object3D.rotation.y = -90*mouse.x/180*Math.PI;

					// let pr = pivotGun.object3D.rotation;
					// console.log("mR=" , pr.x*180/Math.PI , pr.y*180/Math.PI );
				}
			}
			
		}
		
		let shootState = 0;
		function vrSceneTouchEnd(event){
			if (shootState == 0){
				// event.preventDefault();
				// event.stopPropagation();
				shootState = 1;

				let rect = aScene.renderer.domElement.getBoundingClientRect();
				switch ( event.type ) {
					case "mouseup": ////// 20190709 Fei: add this event type for PC mouse
						mouseEnd.x = ( (event.clientX - rect.left) / aScene.renderer.domElement.clientWidth ) * 2 - 1;
						mouseEnd.y = - ( (event.clientY - rect.top) / aScene.renderer.domElement.clientHeight ) * 2 + 1;
						break;
					case "touchend": ////// 20190709 Fei: add this event type for cellphone
						// console.log("endEvent: touchend: event.touches  = ", event.changedTouches[0].clientX, event.changedTouches[0].clientY );
						mouseEnd.x = ( (event.changedTouches[0].clientX - rect.left) / aScene.renderer.domElement.clientWidth ) * 2 - 1;
						mouseEnd.y = - ( (event.changedTouches[0].clientY - rect.top) / aScene.renderer.domElement.clientHeight ) * 2 + 1;
						break;

					default:
						console.log(" startEvent: event.type=", event.type, " not mousedown/touchstart, return ");
						return ;

				}

				//// 弓作一次動畫
				bow.object3D.children[0].animationSlices[0].changed = true;

				
				//// 發射子彈的測試

				let bullet = document.createElement('a-entity');
				bullet.setAttribute("dynamic-body", "mass: 1; shape: sphere;"); //// 碰撞形狀設為球形，才不會有多次碰撞
				bullet.setAttribute("object-type", "bullet"); //// 自行設定的類別，為了碰撞時候區隔
				bullet.setAttribute("scale", "0.6 0.2 0.6");
				bullet.setAttribute("gltf-model", "#_arrow");

				let strength = 8.1; // 固定子彈速度
				if (window.navigator.userAgent.toLowerCase().indexOf("mobile") < 0){
					//// 電腦端： 透過點擊的位置決定發射的方向，固定畫面視角。

					let bulletQuat = new THREE.Quaternion();
					pivotGun.object3D.getWorldQuaternion(bulletQuat);

					let bulletRotation = pivotGun.object3D.rotation.clone();
					bulletRotation.z += Math.PI;
					let rr = {x:  bulletRotation.x*180/Math.PI, y: bulletRotation.y*180/Math.PI, z: bulletRotation.z*180/Math.PI } ;
					// console.log("rr = " , rr );

					let velocity = new THREE.Vector3(0,1,0).applyEuler( bulletRotation ).multiplyScalar( strength ); //// 方向為朝著槍管方向指向射出
					// console.log(" velocity = " , rr, bulletRotation, velocity);
					
					let arrWP = new THREE.Vector3();
					arrow.object3D.getWorldPosition(arrWP);

					bullet.setAttribute("rotation",  rr );
					bullet.setAttribute("velocity", velocity );
					bullet.setAttribute("position", arrWP ); //// 從槍的固定位置射出
					aScene.appendChild(bullet);
				}else{
					//// 手機端：透過點擊的位置決定發射的方向，透過轉動手機來調整視角。

					////
					//// 方案一：不論畫面轉動，依照點擊銀幕位置決定箭矢的射出角度。
					////
					//// 計算箭矢的角度
					// let bulletRotation = new THREE.Euler();
					// bulletRotation.order = "YXZ";
					// bulletRotation.x = (70 + 40*(1+mouseEnd.y) )/180*Math.PI;
					// bulletRotation.y = -90*mouseEnd.x/180*Math.PI;
					// bulletRotation.z = Math.PI;
					// let rr = {x:  bulletRotation.x*180/Math.PI + 0 , y: bulletRotation.y*180/Math.PI + 0, z: bulletRotation.z*180/Math.PI + 0 } ;					
					// let velocity = new THREE.Vector3(0,1,0).applyEuler( bulletRotation ).multiplyScalar( strength ); //// 方向為朝著槍管方向指向射出

					////
					//// 方案二：不論點擊銀幕位置，箭矢保持從預設弓的位置射出，方向也固定。角度從相機來
					////
					
					let bulletRotation = aCamera.object3D.rotation.clone();
					bulletRotation.x += 120/180*Math.PI; //// x方向角度多120，等同於夾角30度
					bulletRotation.z = Math.PI; //// z 方向需要顛倒

					let rr = {x: bulletRotation.x*180/Math.PI, y: bulletRotation.y*180/Math.PI, z: bulletRotation.z*180/Math.PI};
					let velocity = new THREE.Vector3(0,1,0).applyEuler( bulletRotation ).multiplyScalar( strength ); //// 方向為朝著槍管方向指向射出
					// console.log("rr = ", rr  );

					let arrWP = new THREE.Vector3();
					arrow.object3D.getWorldPosition(arrWP);
					bullet.setAttribute("position", arrWP ); //// 從箭的固定位置射出
					bullet.setAttribute("rotation",  rr );

					bullet.setAttribute("velocity", velocity );

					aScene.appendChild(bullet);
				}
			
				//// 兩秒後刪除射出的子彈
				setTimeout(function(){
					// console.log(" bullet = " , bullet.object3D.el );
					if (bullet.object3D.el){
						bullet.remove();
					}
				}, 5000);

				//// 一段時間後才能射出下一發
				setTimeout(function(){
					shootState = 0;
				}, 200);
				
			}
		}

		//// 點擊跳出的提示樣板後開始遊戲
		blocker.onclick =  function(){
			console.log(" _blocker clicked");
			blocker.style.display = "none";
			randomGenerateObject();
		};

		//// 隨機掉落『禮物』，控制固定速度的功能寫在外面，寫在個別會造成卡頓，在固定的時間內尋找場景中所有符合條件的物件賦予固定落下速度
		function randomGenerateObject(_duration , _rate){
			let duration = _duration? _duration: 3000; //// 總共時間
			let rate = _rate? _rate: 5; //// 一秒鐘有幾次
			console.log("_randomGenerateObject start ", duration , rate );

			let period = 1/rate*1000; //// 每次的間隔時間
			let totalCount = duration/1000*rate; //// 總共幾次
			
			let score = 0;
			let generatedCount = 0;
			let posArray = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
			let timer = setInterval( genObject , period);
			function genObject(){
				// console.log("_randomGenerateObject , generatedCount =" , generatedCount );
				generatedCount += 1;

				//// 計算隨機生成的位置。
				//// 使用預先開好的『可選位置』來抽籤決定每個禮物生成的位置。需要限制禮物數量在 15 個。
				let pIndex = Math.floor( Math.random()*posArray.length );//// 從現有『可選位置』中隨機選一個
				let getPIndex = posArray[pIndex];//// 取得選中的位置編號 [0-15]
				let px = Math.floor(getPIndex/4) * 1.3;//// 依照編號計算 x [0-3]
				let pz = (getPIndex%4) * 1.3 ;            //// 依照編號計算 z [0-3] 
				posArray.splice(pIndex, 1); //// 刪除『可選位置』中被選到的位置，代表已經被選過
				let randomPosition = new THREE.Vector3( -1.9 + px, -4 , -9 + pz );

				//// 完全隨機，可能會造成物件重疊，暫時不使用
				// let randomPosition = new THREE.Vector3( 0, -2, -6);
				// randomPosition.x += Math.random()*4 -2;
				// randomPosition.z += Math.random()*4 -2;

				let velocity = new THREE.Vector3(0, 0.75, 0);

				let gift = document.createElement('a-entity');
				gift.setAttribute("static-body", "mass: 1;");
			
				gift.setAttribute("object-type", "gift"); ////自行設置的物件型態

				gift.setAttribute("linearDamping", "1000");
				gift.setAttribute("angularDamping", "1000");
				
				//// 依照排序生成 [1 2 3]分數的氣球各 5 個
				if (generatedCount%3 == 0){
					gift.setAttribute("gltf-model", "#b1");
					gift.setAttribute("score", "1" );
				}else if (generatedCount%3 == 1){
					gift.setAttribute("gltf-model", "#b2");
					gift.setAttribute("score", "2" );
				}else {
					gift.setAttribute("gltf-model", "#b3");
					gift.setAttribute("score", "3" );
				}

				gift.addEventListener('model-loaded', function(evt){
					//// 材質處理，無光標準
					evt.detail.model;
					let objj = gift.getObject3D('mesh');
					objj.traverse(node => {
						if (node.isMesh) {
							node.material = new THREE.MeshBasicMaterial({color: new THREE.Color(1,1,1), name: node.name, skinning: node.material.skinning, map: node.material.map});
							if (node.material.map){
								node.material.map.encoding = THREE.GammaEncoding;
								node.material.map.needsUpdate = true;
							}
							node.material.needsUpdate = true;
						}
					});
				});

				gift.setAttribute("position", randomPosition);
				gift.setAttribute("scale", "0.9 0.9 0.9");
				gift.setAttribute("velocity", velocity );
				// gift.setAttribute("geometry","primitive: sphere; radius: 0.2; segmentsWidth: 18; segmentsHeight: 36 ");
				
				gift.setAttribute("shadow","cast:true; receive:true");

				gift.addEventListener('collide', function(e){					
					// console.log("gift collide: ", e.detail.target.el.object3D , e.detail.body.el.object3D , e.detail.body.el.getAttribute("id") );
					//// 可能會碰撞的物件是球跟地板還有『其他禮物』
					//// 假如『禮物』受到『子彈』碰撞，刪除兩者，並且清除
					if (e.detail.body.el.getAttribute("object-type") == "bullet"){
						//// 刪除子彈
						if (e.detail.body.el.parentEl){
							// console.log(" remove body " , e.detail.body.el.object3D  );
							// e.detail.body.el.remove();
							e.detail.body.el.object3D.el.remove();
						}
						//// 刪除禮物
						if (e.detail.target.el.object3D.el){
							// console.log(" remove target " , e.detail.target.el.object3D  );
							// e.detail.target.el.remove();
							e.detail.target.el.object3D.el.remove();
						}

						let note = e.detail.target.el.getAttribute("score");
						console.log(" score note = " , note );
						
						score += Number(note);

						scoreNow.innerText = "分數："+(score);

					}
					//// 假如『禮物』受到『地板』碰撞，刪除禮物
					if (e.detail.body.el.getAttribute("id") == "ground"){
						e.detail.target.el.remove();
					}

					

				});

				aScene.appendChild(gift);
				//// 達到上限，結束生成
				if (generatedCount == totalCount){
					clearInterval(timer);

					function gameEnd(){
						console.log(" ctrlObj call clearInterval ");
						clearInterval(ctrlObj);

						blocker_score.style.display = "block";

						let userID;
						if ( !localStorage.getItem('userID') || !localStorage.getItem('vendor') ){
							userID = "test1@google";
						}else{
							userID = localStorage.getItem('userID')+"@"+localStorage.getItem('vendor');
						}

						let coins = Math.ceil(score/10);
						let serverUrl = "https://7leyf90jbd.execute-api.ap-northeast-1.amazonaws.com/prod/yongkangMongoAccess";
						let	postData = {
							// ID: "test3"+"@"+"google",
							ID:  userID, 
							coins: coins,
							gameType: "shoot",
							request: 'play',
							requestItem: ''
						};
						fetch( serverUrl , {
							method: 'POST', 
							headers: { 'Content-Type': 'application/json'},
							body: JSON.stringify(postData)
						} ).then(function(response) {
							return response.json();
						}).then(function(isPlayed) {
							console.log("shooting.html, play isPlayed " , isPlayed );

							postData = {
							ID:  userID, 
							request: 'get',
							requestItem: 'userCoins'
							};
							fetch( serverUrl , {
								method: 'POST', 
								headers: { 'Content-Type': 'application/json'},
								body: JSON.stringify(postData)
							} ).then(function(response) {
								return response.json();
							}).then(function(userCoins) {
								let userCurrentCounts = Number(userCoins[0].currentCoins);

								currentCoins.innerHTML = "結算代幣：" + userCurrentCounts + "枚";

								if ( isPlayed[0] == true ){


									if (score == 0){
										previousCoins.innerHTML = "原有代幣：" + (userCurrentCounts) + "枚";
										getCoins.innerHTML = "新增代幣：" + 1 + "枚";
										score_info.innerHTML = "Sorry! 一個氣球都沒有擊中<br>不過參與遊戲還是可以獲得一個永康幣喔";
									}else{
										previousCoins.innerHTML = "原有代幣：" + (userCurrentCounts - coins) + "枚";
										getCoins.innerHTML = "新增代幣：" + coins + "枚";
										score_info.innerHTML = "恭喜你！獲得 " + score + " 分<br>獲得" + coins + "個永康幣";
									}

								}else{

									if (score == 0){
										previousCoins.innerHTML = "原有代幣：" + (userCurrentCounts) + "枚";
										getCoins.innerHTML = "新增代幣：" + 1 + "枚";
										score_info.innerHTML = "Sorry! 一個都沒有擊中<br>今日已經遊玩過了，無法獲得永康幣";
									}else{
										previousCoins.innerHTML = "原有代幣：" + userCurrentCounts + "枚";
										getCoins.innerHTML = "新增代幣：" + 0 + "枚";
										score_info.innerHTML = "恭喜你！獲得 " + score + " 分<br>今日已經遊玩過了，無法獲得永康幣";
									}

								}

							});



						});

						
						//// 點擊『去兌換』
						couponPage.onclick = function(){
							location.replace("/prize-list");
						}

						//// 點擊『排行榜』
						leaderBn.onclick = function(){
							postData = {
								ID:  userID, 
								request: 'get',
								requestItem: 'coinLeaderboard'
							};
							fetch( serverUrl , {
								method: 'POST', 
								headers: { 'Content-Type': 'application/json'},
								body: JSON.stringify(postData)
							} ).then(function(response) {
								return response.json();
							}).then(function(leaderList) {
								
								leadBnModal.style.display = 'block';

								console.log("leaderList = " , leaderList );
								let leaderTable = document.getElementById("leaderTable");
								leaderTable.innerHTML = "";
								let thr = leaderTable.insertRow( 0 );
								let t1 = document.createElement('th') , t2 = document.createElement('th') , t3 = document.createElement('th');
								t1.innerHTML = "排名";
								t2.innerHTML = "用戶名稱";
								t3.innerHTML = "代幣數量";
								thr.appendChild(t1);
								thr.appendChild(t2);
								thr.appendChild(t3);
								leaderList.forEach((currentValue, index) => {
									let row = leaderTable.insertRow( index + 1);
									let rankR = row.insertCell(0);
									let nameR = row.insertCell(1);
									let coinsR = row.insertCell(2);
									rankR.style.width = "20%";
									nameR.style.width = "50%";
									coinsR.style.width = "25%";

									let userName;
									if (currentValue.name == ""){
									userName = "user";
									}else{
									userName = currentValue.name;
									}
									rankR.innerHTML = index + 1;
									nameR.innerHTML = userName;
									coinsR.innerHTML = currentValue.cumulativeCoins;
								});
							});

						}

						closeLeadBnModal.onclick = function(){
							leadBnModal.style.display = 'none';
						}
						
					}

					//// 最後一波釋放後九秒結算
					setTimeout(function(){
						gameEnd();
					}, 13000);
				}
			}

			//// 控制場景中的『禮物』上升速度，
			let velocity = new THREE.Vector3(0, 0.75, 0); //// 這邊設置貌似沒有用..
			let heightThreshold = ground.object3D.position.y;
			var ctrlObj = setInterval(controlObjects, 500 );
			function controlObjects(){
				let needRemoved = [];
				for (let i = 0, len = aScene.children.length; i< len; i++ ){
					if (aScene.children[i]){
						if (aScene.children[i].getAttribute("object-type") == "gift" ){
							if (aScene.children[i].body ){
								// console.log(" ***  " , aScene.children[i].body );
								aScene.children[i].body.velocity.set( velocity.x, velocity.y, velocity.z );

								if (aScene.children[i].body.position.y > heightThreshold){
									needRemoved.push(aScene.children[i]);
								}
							}
							
						}
					}
				}
				for (let i = 0, len=needRemoved.length; i< len; i++){
					needRemoved[i].remove();
				}

				 
				
			}
			
			let timeLeft = 15;
			let intervalId = setInterval(countdownTick, 1000);
			function countdownTick(){
				timeLeft--;
				countdown.textContent = "時間： " + timeLeft;
				if (timeLeft <= 0){
					clearInterval(intervalId);
				}
			}


		}

		let self = {};
		let videoScene = new THREE.Scene();
		self.videoScene = videoScene;
		self.GLRenderer = aScene.renderer;
		aScene.renderer.autoClear = false;
		self.aScene = aScene;

		// renderTick();
		startCamera( function(){
			renderTick();
			//// 即使沒開相機，也能玩
			if (self.video){
				self.video.play();
			}
			
			console.log(" _startCamera callback ");
			loadPage.style.display = "none";
			blocker.style.display = "block";
			blocker.style.pointerEvents = "auto";
			blocker_score.style.pointerEvents = "auto";
			blockState.innerHTML = "請點擊螢幕來開始遊戲";
		});

		function startCamera( callback ){

			let video = document.createElement('video');
			let configuration = { facing: "environment" };
			let texture = new THREE.VideoTexture(video);
			texture.minFilter = THREE.LinearFilter;
			texture.flipY = false;
			texture.format = THREE.RGBFormat; // THREE.RGBAFormat



			console.log(" _startCamera dcwh= " , document.documentElement.clientWidth , document.documentElement.clientHeight );

			if ( navigator.mediaDevices  ) {
				let onError = function(err) { 
					console.error(" _startCamera error:", err); 
					//// 即使沒開相機，也能玩
					if (callback){
						callback();
					}
				};

				let videoSuccess = function(stream){
					window.videoStream = stream;
					video.srcObject = stream;
					video.playsInline = true;
					video.onloadedmetadata = function() {
						function tick_video(){
							if (video.videoWidth > 200 || video.videoHeight > 200){
								console.log("XRFunc.js: tick_video play video[w, h]=", video.videoWidth, video.videoHeight );
								//// 將video 物件記錄下來，在後面等 renderer 開始工作後再啟動
								self.video  = video;
								// video.play();

								//////// set the div size depend on video
								let videoWidth, videoHeight;
								let aDiv = document.getElementById("aDiv");
								let w, h;
								if ( document.documentElement.clientWidth/document.documentElement.clientHeight > video.videoWidth/video.videoHeight ){
									
									w = window.innerWidth  ;
									h = (window.innerWidth/video.videoWidth)* video.videoHeight;

									console.log(" 1 set div size = ", innerWidth, innerHeight, w ,h, videoWidth, videoHeight );
								}else{
									
									w = (window.innerHeight/video.videoHeight) * video.videoWidth ;
									h = window.innerHeight;
									
									console.log(" 2 set div size = ", innerWidth, innerHeight, w ,h, videoWidth, videoHeight );
								}

								//// full fill, left nothing blank
								aDiv.style.width  = w + "px" ;
								aDiv.style.height = h + "px" ;
								//// align the div and body
								aDiv.style.left = ( innerWidth - w )/2 + "px" ;
								aDiv.style.top  = ( innerHeight - h )/2 + "px" ;
								

								aScene.resize(); ////// it must call after renderer resize

								////// setup the camera for 2D scene( 20200314 useless )
								// let camera2D = new THREE.OrthographicCamera( -w/2, w/2, -h/2, h/2, -10, 20000);
								//// 20201110 fei: 設定相機跟背景的時候直接使用『實體相機畫面尺寸』作為設定，手機端基本是[480, 640] 電腦端基本是[640, 480]
								videoWidth = texture.image.videoWidth,  videoHeight = texture.image.videoHeight;

								
								////// setup the camera for background video
								let videoCamera = new THREE.OrthographicCamera( -videoWidth/2, videoWidth/2, -videoHeight/2, videoHeight/2, -10, 20000);
								self.videoCamera = videoCamera;
								
								////// setup videoPlane
								let videoPlane = new THREE.Mesh(
									new THREE.PlaneBufferGeometry( videoWidth , videoHeight ),
									new THREE.MeshBasicMaterial( { map:texture, side: THREE.DoubleSide } ) ,
								);
								// videoPlane.material.depthTest = false;
								// videoPlane.material.depthWrite = false;
								videoPlane.position.set(0, 0, -1 );
								self.videoScene.add( videoPlane );
								
								if ( callback ) { callback(); }

							}else{
								console.log("tick_video else video[w, h]=", video.videoWidth, video.videoHeight );
								setTimeout(tick_video, 100);
							}
						}

						if ( self.videoCamera ){
							console.log("_startCamera: videoCamera exist, donothing ");
						}else{
							console.log("_startCamera: videoCamera not exist, start video ");
							tick_video();
						}
						
					}
					
				}

				
				navigator.mediaDevices.enumerateDevices().then(function(devices) {
					let useDeviceID = false;
					let cameraID, facingString, video_constraints;
					devices = devices.filter(function(devices) { return devices.kind === 'videoinput'; });
					if ( configuration.facing == "environment" ){facingString = "back";} 
					else if (configuration.facing == "user" ){facingString = "front";} 
					else{facingString = "back";}
					for (let i in devices){
						if( devices[i].label.toLowerCase().search( facingString ) != -1  ){ // front back
							cameraID = devices[i].deviceId;
							useDeviceID = true;
						}
					}
					if (useDeviceID){ // PC, android chrome/FireFox, use the specific id by labels.
						console.log("useDeviceID true, cameraID=", cameraID );
						video_constraints = {
							video: {
								width: { min: 320, ideal: 640, max: 1280 },
								height: { min: 240, ideal: 480, max: 800 }, 
								frameRate: { min:15, ideal: 30, max: 60 },
								deviceId: {'exact':cameraID }
							}
						};
					}else{
						let facing;
						if ( configuration.facing ){ //// usually iOS safari and QQ, use "user"/"environment" to start
							facing = configuration.facing;
							console.log("configuration.facing do exist: set facing = ", facing );
							video_constraints = {
								video: {
									width: { min: 320, ideal: 640, max: 1280 },
									height: { min: 240, ideal: 480, max: 800 }, 
									frameRate: { min:15, ideal: 30, max: 60 },
									facingMode: facing
								}
							};
						}else{
							console.log("configuration.facing dosent exist: set facing = environment" );
							video_constraints = {
								video: {
									width: { min: 320, ideal: 640, max: 1280 },
									height: { min: 240, ideal: 480, max: 800 }, 
									frameRate: { min:15, ideal: 30, max: 60 },
									facingMode: 'environment'
								}
							};
						}
					}

					navigator.mediaDevices.getUserMedia( video_constraints ).then(videoSuccess, onError); // successCallback
				
				});

			}

			console.log(" +++++++ ");
		}

		function renderTick(){
			if (self.videoCamera){
				self.GLRenderer.render( self.videoScene, self.videoCamera);
			}	
			self.GLRenderer.clearDepth();
			if (self.aScene.object3D && self.aScene.camera){
				self.GLRenderer.render( self.aScene.object3D, self.aScene.camera );
			}
			// console.log("renderTick");
			requestAnimationFrame(renderTick); // dont use it, because of the haning problem
		};


	</script>

</body>
</html>

